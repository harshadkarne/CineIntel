"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: function() { return /* binding */ api; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// API client for backend communication\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:8000\";\nconst api = {\n    // Dashboard endpoints\n    async getDashboardSummary () {\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard/summary\"));\n        if (!res.ok) throw new Error(\"Failed to fetch dashboard summary\");\n        return res.json();\n    },\n    async getAIRecommendation () {\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard/ai-recommendation\"));\n        if (!res.ok) throw new Error(\"Failed to fetch AI recommendation\");\n        return res.json();\n    },\n    async getBudgetOptimization (genre, budget) {\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard/budget-optimization?genre=\").concat(encodeURIComponent(genre), \"&budget=\").concat(budget));\n        if (!res.ok) throw new Error(\"Failed to fetch budget optimization\");\n        return res.json();\n    },\n    async getReleaseTiming (genre) {\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/dashboard/release-timing?genre=\").concat(encodeURIComponent(genre)));\n        if (!res.ok) throw new Error(\"Failed to fetch release timing\");\n        return res.json();\n    },\n    // Genre endpoints\n    async getGenrePopularity (yearStart, yearEnd, genres) {\n        const params = new URLSearchParams();\n        if (yearStart) params.append(\"year_start\", yearStart.toString());\n        if (yearEnd) params.append(\"year_end\", yearEnd.toString());\n        if (genres && genres.length > 0) params.append(\"genres\", genres.join(\",\"));\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/genre/popularity?\").concat(params));\n        if (!res.ok) throw new Error(\"Failed to fetch genre popularity\");\n        return res.json();\n    },\n    async getHighestGrossing (yearStart, yearEnd) {\n        const params = new URLSearchParams();\n        if (yearStart) params.append(\"year_start\", yearStart.toString());\n        if (yearEnd) params.append(\"year_end\", yearEnd.toString());\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/genre/revenue?\").concat(params));\n        if (!res.ok) throw new Error(\"Failed to fetch highest grossing\");\n        return res.json();\n    },\n    async getSuccessRate (genres) {\n        const params = new URLSearchParams();\n        if (genres && genres.length > 0) params.append(\"genres\", genres.join(\",\"));\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/genre/success-rate?\").concat(params));\n        if (!res.ok) throw new Error(\"Failed to fetch success rate\");\n        return res.json();\n    },\n    async getROI (genres) {\n        const params = new URLSearchParams();\n        if (genres && genres.length > 0) params.append(\"genres\", genres.join(\",\"));\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/genre/roi?\").concat(params));\n        if (!res.ok) throw new Error(\"Failed to fetch ROI\");\n        return res.json();\n    },\n    async getTopGenresByYear (year) {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/genre/top-by-year?year=\").concat(year));\n        return response.json();\n    },\n    async getAllGenres () {\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/genre/list\"));\n        if (!res.ok) throw new Error(\"Failed to fetch genres\");\n        return res.json();\n    },\n    async getYearRange () {\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/genre/year-range\"));\n        if (!res.ok) throw new Error(\"Failed to fetch year range\");\n        return res.json();\n    },\n    // Risk endpoints\n    async getRiskAnalysis () {\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/risk/analysis\"));\n        if (!res.ok) throw new Error(\"Failed to fetch risk analysis\");\n        return res.json();\n    },\n    // Combinations endpoint\n    async getGenreCombinations () {\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/combinations\"));\n        if (!res.ok) throw new Error(\"Failed to fetch genre combinations\");\n        return res.json();\n    },\n    // Prediction endpoint\n    async predictMovie (data) {\n        const res = await fetch(\"\".concat(API_BASE_URL, \"/api/predict\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data)\n        });\n        if (!res.ok) throw new Error(\"Failed to predict movie\");\n        return res.json();\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU07UUFDN0IsT0FBT0gsSUFBSUksSUFBSTtJQUNqQjtJQUVBLHNCQUFzQjtJQUN0QixNQUFNMkIsY0FBYUMsSUFNbEI7UUFDQyxNQUFNaEMsTUFBTSxNQUFNQyxNQUFNLEdBQWdCLE9BQWJQLGNBQWEsaUJBQWU7WUFDckR1QyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsZ0JBQWdCO1lBQ2xCO1lBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0w7UUFDdkI7UUFDQSxJQUFJLENBQUNoQyxJQUFJRSxFQUFFLEVBQUUsTUFBTSxJQUFJQyxNQUFNO1FBQzdCLE9BQU9ILElBQUlJLElBQUk7SUFDakI7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkudHM/NjhhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBUEkgY2xpZW50IGZvciBiYWNrZW5kIGNvbW11bmljYXRpb25cblxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJztcblxuZXhwb3J0IGNvbnN0IGFwaSA9IHtcbiAgLy8gRGFzaGJvYXJkIGVuZHBvaW50c1xuICBhc3luYyBnZXREYXNoYm9hcmRTdW1tYXJ5KCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2Rhc2hib2FyZC9zdW1tYXJ5YCk7XG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIGRhc2hib2FyZCBzdW1tYXJ5Jyk7XG4gICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgZ2V0QUlSZWNvbW1lbmRhdGlvbigpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9kYXNoYm9hcmQvYWktcmVjb21tZW5kYXRpb25gKTtcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggQUkgcmVjb21tZW5kYXRpb24nKTtcbiAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyBnZXRCdWRnZXRPcHRpbWl6YXRpb24oZ2VucmU6IHN0cmluZywgYnVkZ2V0OiBudW1iZXIpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcbiAgICAgIGAke0FQSV9CQVNFX1VSTH0vYXBpL2Rhc2hib2FyZC9idWRnZXQtb3B0aW1pemF0aW9uP2dlbnJlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGdlbnJlKX0mYnVkZ2V0PSR7YnVkZ2V0fWBcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBidWRnZXQgb3B0aW1pemF0aW9uJyk7XG4gICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgZ2V0UmVsZWFzZVRpbWluZyhnZW5yZTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHtBUElfQkFTRV9VUkx9L2FwaS9kYXNoYm9hcmQvcmVsZWFzZS10aW1pbmc/Z2VucmU9JHtlbmNvZGVVUklDb21wb25lbnQoZ2VucmUpfWBcbiAgICApO1xuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCByZWxlYXNlIHRpbWluZycpO1xuICAgIHJldHVybiByZXMuanNvbigpO1xuICB9LFxuXG4gIC8vIEdlbnJlIGVuZHBvaW50c1xuICBhc3luYyBnZXRHZW5yZVBvcHVsYXJpdHkoeWVhclN0YXJ0PzogbnVtYmVyLCB5ZWFyRW5kPzogbnVtYmVyLCBnZW5yZXM/OiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAoeWVhclN0YXJ0KSBwYXJhbXMuYXBwZW5kKCd5ZWFyX3N0YXJ0JywgeWVhclN0YXJ0LnRvU3RyaW5nKCkpO1xuICAgIGlmICh5ZWFyRW5kKSBwYXJhbXMuYXBwZW5kKCd5ZWFyX2VuZCcsIHllYXJFbmQudG9TdHJpbmcoKSk7XG4gICAgaWYgKGdlbnJlcyAmJiBnZW5yZXMubGVuZ3RoID4gMCkgcGFyYW1zLmFwcGVuZCgnZ2VucmVzJywgZ2VucmVzLmpvaW4oJywnKSk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9nZW5yZS9wb3B1bGFyaXR5PyR7cGFyYW1zfWApO1xuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBnZW5yZSBwb3B1bGFyaXR5Jyk7XG4gICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgZ2V0SGlnaGVzdEdyb3NzaW5nKHllYXJTdGFydD86IG51bWJlciwgeWVhckVuZD86IG51bWJlcikge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAoeWVhclN0YXJ0KSBwYXJhbXMuYXBwZW5kKCd5ZWFyX3N0YXJ0JywgeWVhclN0YXJ0LnRvU3RyaW5nKCkpO1xuICAgIGlmICh5ZWFyRW5kKSBwYXJhbXMuYXBwZW5kKCd5ZWFyX2VuZCcsIHllYXJFbmQudG9TdHJpbmcoKSk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9nZW5yZS9yZXZlbnVlPyR7cGFyYW1zfWApO1xuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBoaWdoZXN0IGdyb3NzaW5nJyk7XG4gICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgZ2V0U3VjY2Vzc1JhdGUoZ2VucmVzPzogc3RyaW5nW10pIHtcbiAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgaWYgKGdlbnJlcyAmJiBnZW5yZXMubGVuZ3RoID4gMCkgcGFyYW1zLmFwcGVuZCgnZ2VucmVzJywgZ2VucmVzLmpvaW4oJywnKSk7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9nZW5yZS9zdWNjZXNzLXJhdGU/JHtwYXJhbXN9YCk7XG4gICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHN1Y2Nlc3MgcmF0ZScpO1xuICAgIHJldHVybiByZXMuanNvbigpO1xuICB9LFxuXG4gIGFzeW5jIGdldFJPSShnZW5yZXM/OiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBpZiAoZ2VucmVzICYmIGdlbnJlcy5sZW5ndGggPiAwKSBwYXJhbXMuYXBwZW5kKCdnZW5yZXMnLCBnZW5yZXMuam9pbignLCcpKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2dlbnJlL3JvaT8ke3BhcmFtc31gKTtcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggUk9JJyk7XG4gICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gIH0sXG5cbiAgYXN5bmMgIGdldFRvcEdlbnJlc0J5WWVhcih5ZWFyOiBudW1iZXIpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vZ2VucmUvdG9wLWJ5LXllYXI/eWVhcj0ke3llYXJ9YCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyBnZXRBbGxHZW5yZXMoKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvZ2VucmUvbGlzdGApO1xuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBnZW5yZXMnKTtcbiAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgfSxcblxuICBhc3luYyBnZXRZZWFyUmFuZ2UoKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvZ2VucmUveWVhci1yYW5nZWApO1xuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCB5ZWFyIHJhbmdlJyk7XG4gICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gIH0sXG5cbiAgLy8gUmlzayBlbmRwb2ludHNcbiAgYXN5bmMgZ2V0Umlza0FuYWx5c2lzKCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3Jpc2svYW5hbHlzaXNgKTtcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggcmlzayBhbmFseXNpcycpO1xuICAgIHJldHVybiByZXMuanNvbigpO1xuICB9LFxuXG4gIC8vIENvbWJpbmF0aW9ucyBlbmRwb2ludFxuICBhc3luYyBnZXRHZW5yZUNvbWJpbmF0aW9ucygpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9jb21iaW5hdGlvbnNgKTtcbiAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggZ2VucmUgY29tYmluYXRpb25zJyk7XG4gICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gIH0sXG5cbiAgLy8gUHJlZGljdGlvbiBlbmRwb2ludFxuICBhc3luYyBwcmVkaWN0TW92aWUoZGF0YToge1xuICAgIGdlbnJlOiBzdHJpbmc7XG4gICAgYnVkZ2V0OiBudW1iZXI7XG4gICAgeWVhcjogbnVtYmVyO1xuICAgIGltZGJfcmF0aW5nOiBudW1iZXI7XG4gICAgcnVudGltZTogbnVtYmVyO1xuICB9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvcHJlZGljdGAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwcmVkaWN0IG1vdmllJyk7XG4gICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gIH0sXG59O1xuIl0sIm5hbWVzIjpbIkFQSV9CQVNFX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiYXBpIiwiZ2V0RGFzaGJvYXJkU3VtbWFyeSIsInJlcyIsImZldGNoIiwib2siLCJFcnJvciIsImpzb24iLCJnZXRBSVJlY29tbWVuZGF0aW9uIiwiZ2V0QnVkZ2V0T3B0aW1pemF0aW9uIiwiZ2VucmUiLCJidWRnZXQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRSZWxlYXNlVGltaW5nIiwiZ2V0R2VucmVQb3B1bGFyaXR5IiwieWVhclN0YXJ0IiwieWVhckVuZCIsImdlbnJlcyIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiam9pbiIsImdldEhpZ2hlc3RHcm9zc2luZyIsImdldFN1Y2Nlc3NSYXRlIiwiZ2V0Uk9JIiwiZ2V0VG9wR2VucmVzQnlZZWFyIiwieWVhciIsInJlc3BvbnNlIiwiZ2V0QWxsR2VucmVzIiwiZ2V0WWVhclJhbmdlIiwiZ2V0Umlza0FuYWx5c2lzIiwiZ2V0R2VucmVDb21iaW5hdGlvbnMiLCJwcmVkaWN0TW92aWUiLCJkYXRhIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});